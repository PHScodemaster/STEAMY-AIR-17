// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4949.RobotSteamWorks;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.PIDSourceType;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.CANTalon;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap { 
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Compressor pneumaticsCompressor;
    public static Solenoid pneumaticsLiftSolenoid1;
    public static Solenoid pneumaticsLiftSolenoid2;
    public static Solenoid pneumaticsGobblerSolenoid;
    public static Solenoid pneumaticsRockerSolenoid;
    public static SpeedController pickerpickerMotor;
    public static CANTalon driverfMotorController;
    public static CANTalon driverrMotorController;
    public static CANTalon drivelfMotorController;
    public static CANTalon drivelrMotorController;
    public static RobotDrive driveRobotDrive;
    public static SpeedController climberwinchMotor;
    public static Servo cameraPan;
    public static Servo cameraTilt;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static ADXRS450_Gyro driveADXRS450_Gyro;
    public static Counter driverfEncoder;
    public static Counter driverrEncoder;
    public static Counter drivelfEncoder;
    public static Counter drivelrEncoder;

    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        pneumaticsCompressor = new Compressor(0);
        
        
        pneumaticsLiftSolenoid1 = new Solenoid(0, 0);
        LiveWindow.addActuator("Pneumatics", "LiftSolenoid1", pneumaticsLiftSolenoid1);
        
        pneumaticsLiftSolenoid2 = new Solenoid(0, 1);
        LiveWindow.addActuator("Pneumatics", "LiftSolenoid2", pneumaticsLiftSolenoid2);
        
        pneumaticsGobblerSolenoid = new Solenoid(0, 2);
        LiveWindow.addActuator("Pneumatics", "GobblerSolenoid", pneumaticsGobblerSolenoid);
        
        pneumaticsRockerSolenoid = new Solenoid(0, 3);
        LiveWindow.addActuator("Pneumatics", "RockerSolenoid", pneumaticsRockerSolenoid);
        
        pickerpickerMotor = new Talon(7);
        LiveWindow.addActuator("Picker", "pickerMotor", (Talon) pickerpickerMotor);
        
        driverfMotorController = new CANTalon(2);
        LiveWindow.addActuator("Drive", "rfMotorController", driverfMotorController);
        
        driverrMotorController = new CANTalon(3);
        LiveWindow.addActuator("Drive", "rrMotorController", driverrMotorController);
        
        drivelfMotorController = new CANTalon(1);
        LiveWindow.addActuator("Drive", "lfMotorController", drivelfMotorController);
        
        drivelrMotorController = new CANTalon(0);
        LiveWindow.addActuator("Drive", "lrMotorController", drivelrMotorController);
        
        driveRobotDrive = new RobotDrive(drivelfMotorController, drivelrMotorController,
              driverfMotorController, driverrMotorController);
        
        driveRobotDrive.setSafetyEnabled(true);
        driveRobotDrive.setExpiration(0.1);
        driveRobotDrive.setSensitivity(0.5);
        driveRobotDrive.setMaxOutput(1.0);

        driveRobotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        driveRobotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        climberwinchMotor = new Talon(6);
        LiveWindow.addActuator("Climber", "winchMotor", (Talon) climberwinchMotor);
        
        cameraPan = new Servo(4);
        LiveWindow.addActuator("Camera", "Pan", cameraPan);
        
        cameraTilt = new Servo(5);
        LiveWindow.addActuator("Camera", "Tilt", cameraTilt);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        /**
         * The touchless encoders are actually unidirectional counters.
         * 
         * There are a few different parameters that can be set to control 
         * various aspects of the counter behavior:
         * 
         * Max Period - The maximum period (in seconds) where the device is 
         * still considered moving. This value is used to determine the state 
         * of the getStopped() method and effect the output of the getPeriod() 
         * and getRate() methods.
         * 
         * Update When Empty - Setting this to false will keep the most recent 
         * period on the counter when the counter is determined to be stalled 
         * (based on the Max Period described above). Setting this parameter to 
         * True will return 0 as the period of a stalled counter.
         * 
         * Reverse Direction - Valid in external direction mode only. Setting 
         * this parameter to true reverses the counting direction of the external 
         * direction mode of the counter.
         * 
         * Samples to Average - Sets the number of samples to average when 
         * determining the period. Averaging may be desired to account for 
         * mechanical imperfections (such as unevenly spaced reflectors when 
         * using a reflective sensor as an encoder) or as oversampling to 
         * increase resolution. Valid values are 1 to 127 samples.
         * 
         * Distance Per Pulse - Sets the multiplier used to determine distance 
         * from count when using the getDistance() method.  These counters should
         * be triggering on the 9 vanes of the mecanum wheel.  The circumference
         * of the wheel is 31.4 cm. This should amount to 3.5 cm per pulse.
         */
        
        driverfEncoder = new Counter(2);
        driverfEncoder.setMaxPeriod(.1);
        driverfEncoder.setUpdateWhenEmpty(true);
        driverfEncoder.setReverseDirection(false);
        driverfEncoder.setSamplesToAverage(6);
        driverfEncoder.setDistancePerPulse(3.5);
		driverfEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        LiveWindow.addActuator("Encoder", "Right Front", driverfEncoder);

        driverrEncoder = new Counter(3);
        driverrEncoder.setMaxPeriod(.1);
        driverrEncoder.setUpdateWhenEmpty(true);
        driverrEncoder.setReverseDirection(false);
        driverrEncoder.setSamplesToAverage(6);
        driverrEncoder.setDistancePerPulse(3.5);
		driverrEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        LiveWindow.addActuator("Encoder", "Right Rear", driverrEncoder);
        
        drivelfEncoder = new Counter(1);
        drivelfEncoder.setMaxPeriod(.1);
        drivelfEncoder.setUpdateWhenEmpty(true);
        drivelfEncoder.setReverseDirection(false);
        drivelfEncoder.setSamplesToAverage(6);
        drivelfEncoder.setDistancePerPulse(3.5);
		drivelfEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        LiveWindow.addActuator("Encoder", "Left Front", drivelfEncoder);

        drivelrEncoder = new Counter(0);
        drivelrEncoder.setMaxPeriod(.1);
        drivelrEncoder.setUpdateWhenEmpty(true);
        drivelrEncoder.setReverseDirection(false);
        drivelrEncoder.setSamplesToAverage(6);
        drivelrEncoder.setDistancePerPulse(3.5);
		drivelrEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        LiveWindow.addActuator("Encoder", "Left Rear", drivelrEncoder);

    }
}
