// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4949.RobotSteamWorks.subsystems;

import org.usfirst.frc4949.RobotSteamWorks.commands.*;
import org.usfirst.frc4949.RobotSteamWorks.RobotMap;
import org.usfirst.frc4949.RobotSteamWorks.TargetBoiler;
import org.usfirst.frc4949.RobotSteamWorks.TargetLift;
import org.opencv.imgproc.Imgproc;
import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import edu.wpi.cscore.CvSink;
import edu.wpi.cscore.CvSource;
import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.vision.VisionRunner;
import edu.wpi.first.wpilibj.vision.VisionThread;
import com.ctre.CANTalon;

/**
 *
 */
public class Camera extends Subsystem { 

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	
	

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final Servo pan = RobotMap.cameraPan;
    private final Servo tilt = RobotMap.cameraTilt;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private static final int IMG_WIDTH = 320;
    private static final int IMG_HEIGHT = 240;

  	Thread visionThread;
    private double centerX = 0.0;

    private final Object imgLock = new Object();


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
 
    /**
     * Pipeline processing comes from the wpilib tutorial, modified slightly to
     * fit into the Camera subsystem.  It is assumed that the GRIP processing for
     * the boiler and the lift required two different sequences and the generated 
     * code was loaded up at the top level.
     * 
     * The module TargetBoiler.java was created using GRIP against the images
     * provided by WPI and then repointed to use the USB Camera as a source.  It
     * was exported with the option to implement the WPILIB Vision Pipeline.
     */
    
     public void initThreadToTargetLift() {
     	
         UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
         camera.setResolution(IMG_WIDTH, IMG_HEIGHT);
  
        visionThread = new VisionThread(camera, 
       		new TargetLift(), 
        		pipeline -> {
             if (!pipeline.filterContoursOutput().isEmpty()) {
                  Rect r = Imgproc.boundingRect(pipeline.filterContoursOutput().get(0));
                  synchronized (imgLock) {
                       centerX = r.x + (r.width / 2);
                  }
             }
        });
        visionThread.start();
    }
    
    public void killThreadToTargetLift() {
    	
    }
    
    /**
     * The module TargetBoiler.java was created using GRIP against the images
     * provided by WPI and then repointed to use the USB Camera as a source.  It
     * was exported with the option to implement the WPILIB Vision Pipeline.
     */
    
    public void initThreadToTargetBoiler() {
    	
        UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
        camera.setResolution(IMG_WIDTH, IMG_HEIGHT);
  
        visionThread = new VisionThread(camera, 
        		new TargetBoiler(), 
        		pipeline -> {
             if (!pipeline.filterContoursOutput().isEmpty()) {
                  Rect r = Imgproc.boundingRect(pipeline.filterContoursOutput().get(0));
                  synchronized (imgLock) {
                       centerX = r.x + (r.width / 2);
                  }
             }
        });
        visionThread.start();
    }
    
    public void killThreadToTargetBoiler() {
    	
    }
    
    /**
     * In the sample, the center of the target in the X axis was used immediately
     * to steer the robot on the line to the target.  It was written up in the
     * main robot sequence.  Here, the code for drive to boiler and drive to lift 
     * are separate commands that will be called sequentially in the command group.
     * @return
     */
   
    public double getTurn() {
        double centerX;
        synchronized (imgLock) {
             centerX = this.centerX;
        }
        double turn = centerX - (IMG_WIDTH / 2);
        return turn;
    }
    
    
}
